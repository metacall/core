/* automatically generated by rust-bindgen 0.71.1 */

pub type __pid_t = ::std::os::raw::c_int;
pub type pid_t = __pid_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum metacall_allocator_id {
    METACALL_ALLOCATOR_STD = 0,
    METACALL_ALLOCATOR_NGINX = 1,
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create an allocator instance\n\n  @param[in] allocator_id\n    Type of allocator to be created\n\n  @param[in] ctx\n    Context of the allocator\n\n  @return\n    Pointer to allocator if success, null otherwise"]
    pub fn metacall_allocator_create(
        allocator_id: metacall_allocator_id,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Reserve memory from an allocator instance\n\n  @param[in] allocator\n    Pointer to allocator instance\n\n  @param[in] size\n    Size in bytes to be allocated\n\n  @return\n    Pointer to allocated data on success, null otherwise"]
    pub fn metacall_allocator_alloc(
        allocator: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Reallocate memory from an allocator instance\n\n  @param[in] allocator\n    Pointer to allocator instance\n\n  @param[in] data\n    Original pointer to data\n\n  @param[in] size\n    Original size in bytes\n\n  @param[in] new_size\n    New size in bytes to be reallocated\n\n  @return\n    Pointer to new reallocated data on success, null otherwise"]
    pub fn metacall_allocator_realloc(
        allocator: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        size: usize,
        new_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Free memory from an allocator instance\n\n  @param[in] allocator\n    Pointer to allocator instance\n\n  @param[in] data\n    Pointer to data to be freed"]
    pub fn metacall_allocator_free(
        allocator: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "  @brief\n    Destroy an allocator instance\n\n  @param[in] allocator\n    Pointer to allocator instance"]
    pub fn metacall_allocator_destroy(allocator: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct metacall_exception_type {
    pub message: *const ::std::os::raw::c_char,
    pub label: *const ::std::os::raw::c_char,
    pub code: i64,
    pub stacktrace: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of metacall_exception_type"][::std::mem::size_of::<metacall_exception_type>() - 32usize];
    ["Alignment of metacall_exception_type"]
        [::std::mem::align_of::<metacall_exception_type>() - 8usize];
    ["Offset of field: metacall_exception_type::message"]
        [::std::mem::offset_of!(metacall_exception_type, message) - 0usize];
    ["Offset of field: metacall_exception_type::label"]
        [::std::mem::offset_of!(metacall_exception_type, label) - 8usize];
    ["Offset of field: metacall_exception_type::code"]
        [::std::mem::offset_of!(metacall_exception_type, code) - 16usize];
    ["Offset of field: metacall_exception_type::stacktrace"]
        [::std::mem::offset_of!(metacall_exception_type, stacktrace) - 24usize];
};
pub type metacall_exception = *mut metacall_exception_type;
unsafe extern "C" {
    #[doc = "  @brief\n    Retrieve the exception from a value, it can be either a throwable value with an exception inside or an exception itself\n\n  @param[in] v\n    Value that represents the exception to be retrieved\n\n  @param[out] ex\n    Exception that will be used as out parameter, the lifetime of the struct fields is attached to @v\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_error_from_value(
        v: *mut ::std::os::raw::c_void,
        ex: metacall_exception,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Retrieve last error that has happened after a call to any API from MetaCall\n\n  @param[out] ex\n    Exception that will be used as out parameter, the lifetime of the struct fields is attached to the internal MetaCall exception\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_error_last(ex: metacall_exception) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Clear last error that has happened after a call to any API from MetaCall"]
    pub fn metacall_error_clear();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum metacall_log_id {
    METACALL_LOG_STDIO = 0,
    METACALL_LOG_FILE = 1,
    METACALL_LOG_SOCKET = 2,
    METACALL_LOG_SYSLOG = 3,
    METACALL_LOG_NGINX = 4,
    METACALL_LOG_CUSTOM = 5,
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a log instance\n\n  @param[in] log_id\n    Type of log to be created\n\n  @param[in] ctx\n    Context of the log (a pointer to metacall_log_{stdio, file, socket, syslog, nginx, custom}_type)\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_log(
        log_id: metacall_log_id,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum metacall_value_id {
    METACALL_BOOL = 0,
    METACALL_CHAR = 1,
    METACALL_SHORT = 2,
    METACALL_INT = 3,
    METACALL_LONG = 4,
    METACALL_FLOAT = 5,
    METACALL_DOUBLE = 6,
    METACALL_STRING = 7,
    METACALL_BUFFER = 8,
    METACALL_ARRAY = 9,
    METACALL_MAP = 10,
    METACALL_PTR = 11,
    METACALL_FUTURE = 12,
    METACALL_FUNCTION = 13,
    METACALL_NULL = 14,
    METACALL_CLASS = 15,
    METACALL_OBJECT = 16,
    METACALL_EXCEPTION = 17,
    METACALL_THROWABLE = 18,
    METACALL_SIZE = 19,
    METACALL_INVALID = 20,
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from boolean @b\n\n  @param[in] b\n    Boolean will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_bool(b: ::std::os::raw::c_uchar) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from char @c\n\n  @param[in] c\n    Character will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_char(c: ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from short @s\n\n  @param[in] s\n    Short will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_short(s: ::std::os::raw::c_short) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from integer @i\n\n  @param[in] i\n    Integer will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_int(i: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from long @l\n\n  @param[in] l\n    Long integer will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_long(l: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from single precision floating point number @f\n\n  @param[in] f\n    Float will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_float(f: f32) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from double precision floating point number @d\n\n  @param[in] d\n    Double will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_double(d: f64) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from a C string @str\n\n  @param[in] str\n    Constant string will be copied into value (needs to be null terminated)\n\n  @param[in] length\n    Length of the constant string\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_string(
        str_: *const ::std::os::raw::c_char,
        length: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value buffer from array @buffer\n\n  @param[in] buffer\n    Constant memory block will be copied into value array\n\n  @param[in] size\n    Size in bytes of data contained in the array\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_buffer(
        buffer: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value array from array of values @values\n\n  @param[in] values\n    Constant array of values will be copied into value list\n\n  @param[in] size\n    Number of elements contained in the array\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_array(
        values: *mut *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value map from array of tuples @map\n\n  @param[in] tuples\n    Constant array of tuples will be copied into value map\n\n  @param[in] size\n    Number of elements contained in the map\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_map(
        tuples: *mut *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from pointer @ptr\n\n  @param[in] ptr\n    Pointer to constant data will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_ptr(
        ptr: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from future @f\n\n  @param[in] f\n    Pointer to constant data will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_future(
        f: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from function @f\n\n  @param[in] f\n    Pointer to constant data will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_function(
        f: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from function @f binding a closure @c to it\n\n  @param[in] f\n    Pointer to constant data will be copied into value\n\n  @param[in] c\n    Pointer to closure that will be binded into function @f\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_function_closure(
        f: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value of type null\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_null() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from class @c\n\n  @param[in] c\n    Pointer to constant data will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_class(
        c: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from object @o\n\n  @param[in] o\n    Pointer to constant data will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_object(
        o: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from exception @ex\n\n  @param[in] ex\n    Pointer to constant data will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_exception(
        ex: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a value from throwable @th\n\n  @param[in] th\n    Pointer to constant data will be copied into value\n\n  @return\n    Pointer to value if success, null otherwhise"]
    pub fn metacall_value_create_throwable(
        th: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Returns the size of the value\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Size in bytes of the value"]
    pub fn metacall_value_size(v: *mut ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Returns the amount of values this value contains\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Number of values @v represents"]
    pub fn metacall_value_count(v: *mut ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide type id of value\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Return type id assigned to value"]
    pub fn metacall_value_id(v: *mut ::std::os::raw::c_void) -> metacall_value_id;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide type id in a readable form (as string) of a type id\n\n  @param[in] id\n    Value type identifier\n\n  @return\n    Return string related to the type id"]
    pub fn metacall_value_id_name(id: metacall_value_id) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide type id in a readable form (as string) of value\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Return string related to the type id assigned to value"]
    pub fn metacall_value_type_name(
        v: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Deep copies the value @v, the result copy resets\n    the reference counter and ownership, including the finalizer\n\n  @param[in] v\n    Reference to the value to be copied\n\n  @return\n    Copy of the value @v on success, null otherwhise"]
    pub fn metacall_value_copy(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Creates a new pointer value, with a reference to the\n    data contained inside the value @v. For example:\n\n    void *v = metacall_value_create_int(20);\n    void *ptr = metacall_value_reference(v);\n\n    In this case, void *ptr is a value equivalent to int*,\n    and it points directly to the integer contained in void *v.\n    Note that if we destroy the value @v, the reference will\n    point to already freed memory, causing use-after-free when used.\n\n  @param[in] v\n    Reference to the value to be referenced\n\n  @return\n    A new value of type pointer, pointing to the @v data"]
    pub fn metacall_value_reference(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    If you pass a reference previously created (i.e a value of\n    type pointer, pointing to another value), it returns the\n    original value. It does not modify the memory of the values\n    neither allocates anything. If the value @v is pointing to\n    has been deleted, it will cause an use-after-free. For example:\n\n    void *v = metacall_value_create_int(20);\n    void *ptr = metacall_value_reference(v);\n    void *w = metacall_value_dereference(ptr);\n    assert(v == w); // Both are the same value\n\n  @param[in] v\n    Reference to the value to be dereferenced\n\n  @return\n    The value containing the data which ptr is pointing to"]
    pub fn metacall_value_dereference(
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Copies the ownership from @src to @dst, including the finalizer,\n    and resets the owner and finalizer of @src\n\n  @param[in] src\n    Source value which will lose the ownership\n\n  @param[in] dst\n    Destination value which will recieve the ownership"]
    pub fn metacall_value_move(src: *mut ::std::os::raw::c_void, dest: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to boolean\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to boolean"]
    pub fn metacall_value_to_bool(v: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to char\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to char"]
    pub fn metacall_value_to_char(v: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to short\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to short"]
    pub fn metacall_value_to_short(v: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to integer\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to integer"]
    pub fn metacall_value_to_int(v: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to long integer\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to long integer"]
    pub fn metacall_value_to_long(v: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to single precision floating point\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to float"]
    pub fn metacall_value_to_float(v: *mut ::std::os::raw::c_void) -> f32;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to double precision floating point\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to dobule"]
    pub fn metacall_value_to_double(v: *mut ::std::os::raw::c_void) -> f64;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to string\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to C string (null terminated)"]
    pub fn metacall_value_to_string(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to buffer\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to memory block"]
    pub fn metacall_value_to_buffer(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to array of values\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to array of values"]
    pub fn metacall_value_to_array(
        v: *mut ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to map\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to map (array of tuples (array of values))"]
    pub fn metacall_value_to_map(
        v: *mut ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to pointer\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to pointer"]
    pub fn metacall_value_to_ptr(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to future\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to future"]
    pub fn metacall_value_to_future(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to function\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to function"]
    pub fn metacall_value_to_function(
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to null\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to null"]
    pub fn metacall_value_to_null(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to class\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to class"]
    pub fn metacall_value_to_class(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to object\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to object"]
    pub fn metacall_value_to_object(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to exception\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to exception"]
    pub fn metacall_value_to_exception(
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v to throwable\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value converted to throwable"]
    pub fn metacall_value_to_throwable(
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign boolean @b to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] b\n    Boolean to be assigned to value @v\n\n  @return\n    Value with boolean @b assigned to it"]
    pub fn metacall_value_from_bool(
        v: *mut ::std::os::raw::c_void,
        b: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign character @c to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] c\n    Character to be assigned to value @v\n\n  @return\n    Value with char @c assigned to it"]
    pub fn metacall_value_from_char(
        v: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign short @s to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] s\n    Short to be assigned to value @v\n\n  @return\n    Value with short @s assigned to it"]
    pub fn metacall_value_from_short(
        v: *mut ::std::os::raw::c_void,
        s: ::std::os::raw::c_short,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign integer @i to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] i\n    Integer to be assigned to value @v\n\n  @return\n    Value with integer @i assigned to it"]
    pub fn metacall_value_from_int(
        v: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign long integer @l to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] l\n    Long integer to be assigned to value @v\n\n  @return\n    Value with long @l assigned to it"]
    pub fn metacall_value_from_long(
        v: *mut ::std::os::raw::c_void,
        l: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign single precision floating point @f to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] f\n    Float to be assigned to value @v\n\n  @return\n    Value with float @f assigned to it"]
    pub fn metacall_value_from_float(
        v: *mut ::std::os::raw::c_void,
        f: f32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign double precision floating point @d to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] d\n    Double to be assigned to value @v\n\n  @return\n    Value with double @d assigned to it"]
    pub fn metacall_value_from_double(
        v: *mut ::std::os::raw::c_void,
        d: f64,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign string @str to value @v, truncates to @v size if it is smaller\n    than @length + 1. It does not add null terminator if truncated.\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] str\n    Constant string to be assigned to value @v (it needs to be null terminated)\n\n  @param[in] length\n    Length of the constant string @str\n\n  @return\n    Value with string @str assigned to it"]
    pub fn metacall_value_from_string(
        v: *mut ::std::os::raw::c_void,
        str_: *const ::std::os::raw::c_char,
        length: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign array @buffer to value buffer @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] buffer\n    Constant array to be assigned to value @v\n\n  @param[in] size\n    Number of elements contained in @buffer\n\n  @return\n    Value with array @buffer assigned to it"]
    pub fn metacall_value_from_buffer(
        v: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign array of values @values to value array @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] values\n    Constant array of values to be assigned to value array @v\n\n  @param[in] size\n    Number of values contained in constant array @values\n\n  @return\n    Value with array of values @values assigned to it"]
    pub fn metacall_value_from_array(
        v: *mut ::std::os::raw::c_void,
        values: *mut *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign array of values @values to value map @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] tuples\n    Constant array of tuples to be assigned to value map @v\n\n  @param[in] size\n    Number of values contained in constant array @tuples\n\n  @return\n    Value with array of tuples @tuples assigned to it"]
    pub fn metacall_value_from_map(
        v: *mut ::std::os::raw::c_void,
        tuples: *mut *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign pointer reference @ptr to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] ptr\n    Pointer to be assigned to value @v\n\n  @return\n    Value with pointer @ptr assigned to it"]
    pub fn metacall_value_from_ptr(
        v: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign future @f to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] f\n    Future to be assigned to value @v\n\n  @return\n    Value with future @f assigned to it"]
    pub fn metacall_value_from_future(
        v: *mut ::std::os::raw::c_void,
        f: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign function @f to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] f\n    Function to be assigned to value @v\n\n  @return\n    Value with function @f assigned to it"]
    pub fn metacall_value_from_function(
        v: *mut ::std::os::raw::c_void,
        f: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign null to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @return\n    Value with null assigned to it"]
    pub fn metacall_value_from_null(v: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign class @c to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] c\n    Class to be assigned to value @v\n\n  @return\n    Value with class @c assigned to it"]
    pub fn metacall_value_from_class(
        v: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign object @o to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] o\n    Object to be assigned to value @v\n\n  @return\n    Value with object @o assigned to it"]
    pub fn metacall_value_from_object(
        v: *mut ::std::os::raw::c_void,
        o: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign exception @ex to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] ex\n    Exception to be assigned to value @v\n\n  @return\n    Value with exception @ex assigned to it"]
    pub fn metacall_value_from_exception(
        v: *mut ::std::os::raw::c_void,
        ex: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Assign throwable @th to value @v\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] th\n    Throwable to be assigned to value @v\n\n  @return\n    Value with throwable @th assigned to it"]
    pub fn metacall_value_from_throwable(
        v: *mut ::std::os::raw::c_void,
        th: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Casts a value to a new type @id\n\n  @param[in] v\n    Reference to the value\n\n  @param[in] id\n    New type id of value to be casted\n\n  @return\n    Casted value or reference to @v if casting is between equivalent types"]
    pub fn metacall_value_cast(
        v: *mut ::std::os::raw::c_void,
        id: metacall_value_id,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to boolean\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to boolean"]
    pub fn metacall_value_cast_bool(v: *mut *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to char\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to char"]
    pub fn metacall_value_cast_char(v: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to short\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to short"]
    pub fn metacall_value_cast_short(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_short;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to int\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to int"]
    pub fn metacall_value_cast_int(v: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to long\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to long"]
    pub fn metacall_value_cast_long(v: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to float\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to float"]
    pub fn metacall_value_cast_float(v: *mut *mut ::std::os::raw::c_void) -> f32;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to double\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to double"]
    pub fn metacall_value_cast_double(v: *mut *mut ::std::os::raw::c_void) -> f64;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to string\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to a C string (null terminated)"]
    pub fn metacall_value_cast_string(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to buffer\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to buffer"]
    pub fn metacall_value_cast_buffer(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to array\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to array of values"]
    pub fn metacall_value_cast_array(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to map\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to map"]
    pub fn metacall_value_cast_map(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to ptr\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to ptr"]
    pub fn metacall_value_cast_ptr(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to future\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to future"]
    pub fn metacall_value_cast_future(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to function\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to function"]
    pub fn metacall_value_cast_function(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to null\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to null"]
    pub fn metacall_value_cast_null(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to class\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to class"]
    pub fn metacall_value_cast_class(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to object\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to object"]
    pub fn metacall_value_cast_object(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to exception\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to exception"]
    pub fn metacall_value_cast_exception(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert value @v implicitly to throwable\n\n  @param[in] v\n    Reference to the reference of the value\n\n  @return\n    Value converted to throwable"]
    pub fn metacall_value_cast_throwable(
        v: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Destroy a value from scope stack\n\n  @param[in] v\n    Reference to the value"]
    pub fn metacall_value_destroy(v: *mut ::std::os::raw::c_void);
}
pub type metacall_pid = pid_t;
pub type metacall_pre_fork_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type metacall_post_fork_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: metacall_pid,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = "  @brief\n    Initialize fork detours and allocate shared memory\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_fork_initialize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Set fork hook callback\n\n  @param[in] pre_callback\n    Callback to be called before fork detour is executed\n\n  @param[in] post_callback\n    Callback to be called after fork detour is executed"]
    pub fn metacall_fork(
        pre_callback: metacall_pre_fork_callback_ptr,
        post_callback: metacall_post_fork_callback_ptr,
    );
}
unsafe extern "C" {
    #[doc = "  @brief\n    Unregister fork detours and destroy shared memory\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_fork_destroy() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct metacall_initialize_configuration_type {
    pub tag: *mut ::std::os::raw::c_char,
    pub options: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of metacall_initialize_configuration_type"]
        [::std::mem::size_of::<metacall_initialize_configuration_type>() - 16usize];
    ["Alignment of metacall_initialize_configuration_type"]
        [::std::mem::align_of::<metacall_initialize_configuration_type>() - 8usize];
    ["Offset of field: metacall_initialize_configuration_type::tag"]
        [::std::mem::offset_of!(metacall_initialize_configuration_type, tag) - 0usize];
    ["Offset of field: metacall_initialize_configuration_type::options"]
        [::std::mem::offset_of!(metacall_initialize_configuration_type, options) - 8usize];
};
pub type metacall_await_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct metacall_await_callbacks_type {
    pub resolve: metacall_await_callback,
    pub reject: metacall_await_callback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of metacall_await_callbacks_type"]
        [::std::mem::size_of::<metacall_await_callbacks_type>() - 16usize];
    ["Alignment of metacall_await_callbacks_type"]
        [::std::mem::align_of::<metacall_await_callbacks_type>() - 8usize];
    ["Offset of field: metacall_await_callbacks_type::resolve"]
        [::std::mem::offset_of!(metacall_await_callbacks_type, resolve) - 0usize];
    ["Offset of field: metacall_await_callbacks_type::reject"]
        [::std::mem::offset_of!(metacall_await_callbacks_type, reject) - 8usize];
};
pub type metacall_await_callbacks = metacall_await_callbacks_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct metacall_version_type {
    pub major: ::std::os::raw::c_uint,
    pub minor: ::std::os::raw::c_uint,
    pub patch: ::std::os::raw::c_uint,
    pub revision: *const ::std::os::raw::c_char,
    pub str_: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of metacall_version_type"][::std::mem::size_of::<metacall_version_type>() - 40usize];
    ["Alignment of metacall_version_type"]
        [::std::mem::align_of::<metacall_version_type>() - 8usize];
    ["Offset of field: metacall_version_type::major"]
        [::std::mem::offset_of!(metacall_version_type, major) - 0usize];
    ["Offset of field: metacall_version_type::minor"]
        [::std::mem::offset_of!(metacall_version_type, minor) - 4usize];
    ["Offset of field: metacall_version_type::patch"]
        [::std::mem::offset_of!(metacall_version_type, patch) - 8usize];
    ["Offset of field: metacall_version_type::revision"]
        [::std::mem::offset_of!(metacall_version_type, revision) - 16usize];
    ["Offset of field: metacall_version_type::str_"]
        [::std::mem::offset_of!(metacall_version_type, str_) - 24usize];
    ["Offset of field: metacall_version_type::name"]
        [::std::mem::offset_of!(metacall_version_type, name) - 32usize];
};
unsafe extern "C" {
    #[doc = "  @brief\n    Returns default serializer used by MetaCall\n\n  @return\n    Name of the serializer to be used with serialization methods"]
    pub fn metacall_serial() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Disables MetaCall logs, must be called before @metacall_initialize.\n\n   When initializing MetaCall, it initializes a default logs to stdout\n   if none was defined. If you want to benchmark or simply disable this\n   default logs, you can call to this function before @metacall_initialize."]
    pub fn metacall_log_null();
}
unsafe extern "C" {
    #[doc = "  @brief\n    Flags to be set in MetaCall library\n\n  @param[in] flags\n    Combination of flags referring to definitions METACALL_FLAGS_*"]
    pub fn metacall_flags(flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "  @brief\n    Initialize MetaCall library\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_initialize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Initialize MetaCall library with configuration arguments\n\n  @param[in] initialize_config\n    Extension of the script to be loaded in memory with data to be injected\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_initialize_ex(
        initialize_config: *mut metacall_initialize_configuration_type,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Initialize MetaCall application arguments\n\n  @param[in] argc\n    Number of additional parameters to be passed to the runtime when initializing\n\n  @param[in] argv\n    Additional parameters to be passed to the runtime when initializing (when using MetaCall as an application)"]
    pub fn metacall_initialize_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the number of arguments in which MetaCall was initialized\n\n  @return\n    An integer equal or greater than zero"]
    pub fn metacall_argc() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the arguments in which MetaCall was initialized\n\n  @return\n    A pointer to an array of strings with the additional arguments"]
    pub fn metacall_argv() -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Check if script context is loaded by @tag\n\n  @param[in] tag\n    Extension of the script (if tag is NULL, it returns the status of the whole MetaCall instance)\n\n  @return\n    Zero if context is initialized, different from zero otherwise"]
    pub fn metacall_is_initialized(tag: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Amount of function call arguments supported by MetaCall\n\n  @return\n    Number of arguments suported"]
    pub fn metacall_args_size() -> usize;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Set a execution path defined by @path to the extension script @tag\n\n  @param[in] tag\n    Extension of the script\n\n  @param[in] path\n    Path to be loaded\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_execution_path(
        tag: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Set a execution path defined by @path to the extension script @tag with length\n\n  @param[in] tag\n    Extension of the script\n\n  @param[in] tag_length\n    Length of the extension of the tag\n\n  @param[in] path\n    Path to be loaded\n\n  @param[in] path_length\n    Length of the path\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_execution_path_s(
        tag: *const ::std::os::raw::c_char,
        tag_length: usize,
        path: *const ::std::os::raw::c_char,
        path_length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Loads a script from file specified by @path\n\n  @param[in] tag\n    Extension of the script\n\n  @param[in] paths\n    Path array of files\n\n  @param[in] size\n    Size of the array @paths\n\n  @param[inout] handle\n    Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are\n    propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide).\n    Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the\n    created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated\n    to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated\n    handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated\n    to the previously allocated handle, and it will behave as a in parameter.\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_load_from_file(
        tag: *const ::std::os::raw::c_char,
        paths: *mut *const ::std::os::raw::c_char,
        size: usize,
        handle: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Loads a script from memory\n\n  @param[in] tag\n    Extension of the script\n\n  @param[in] buffer\n    Memory block representing the string of the script\n\n  @param[in] size\n    Memory block representing the string of the script\n\n  @param[inout] handle\n    Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are\n    propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide).\n    Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the\n    created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated\n    to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated\n    handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated\n    to the previously allocated handle, and it will behave as a in parameter.\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_load_from_memory(
        tag: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_char,
        size: usize,
        handle: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Loads a package of scrips from file specified by @path into loader defined by @extension\n\n  @param[in] tag\n    Extension of the script\n\n  @param[in] path\n    Path of the package\n\n  @param[inout] handle\n    Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are\n    propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide).\n    Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the\n    created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated\n    to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated\n    handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated\n    to the previously allocated handle, and it will behave as a in parameter.\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_load_from_package(
        tag: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        handle: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Loads a a list of scrips from configuration specified by @path into loader\n    with the following format:\n        {\n            \"language_id\": \"<tag>\",\n            \"path\": \"<path>\",\n            \"scripts\": [ \"<script0>\", \"<script1>\", ..., \"<scriptN>\" ]\n        }\n\n  @param[in] path\n    Path of the configuration\n\n  @param[inout] handle\n    Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are\n    propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide).\n    Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the\n    created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated\n    to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated\n    handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated\n    to the previously allocated handle, and it will behave as a in parameter.\n\n  @param[in] allocator\n    Pointer to allocator will allocate the configuration\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_load_from_configuration(
        path: *const ::std::os::raw::c_char,
        handle: *mut *mut ::std::os::raw::c_void,
        allocator: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by value array @args\n\n  @param[in] name\n    Name of the function\n\n  @param[in] args\n    Array of pointers to data\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallv(
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by value array @args\n\n  @param[in] name\n    Name of the function\n\n  @param[in] args\n    Array of pointers to data\n\n  @param[in] size\n    Number of elements of the call\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallv_s(
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by handle @handle value array @args\n    This function allows to avoid name collisions when calling functions by name\n\n  @param[in] handle\n    Handle where the function belongs\n\n  @param[in] name\n    Name of the function\n\n  @param[in] args\n    Array of pointers to data\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallhv(
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by handle @handle value array @args\n    This function allows to avoid name collisions when calling functions by name\n    Includes @size in order to allow variadic arguments or safe calls\n\n  @param[in] handle\n    Handle where the function belongs\n\n  @param[in] name\n    Name of the function\n\n  @param[in] args\n    Array of pointers to data\n\n  @param[in] size\n    Number of elements of the call\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallhv_s(
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by variable arguments @va_args\n\n  @param[in] name\n    Name of the function\n\n  @param[in] va_args\n    Varidic function parameters\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacall(name: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by type array @ids and variable arguments @va_args\n\n  @param[in] name\n    Name of the function\n\n  @param[in] ids\n    Array of types refered to @va_args\n\n  @param[in] va_args\n    Varidic function parameters\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallt(
        name: *const ::std::os::raw::c_char,
        ids: *const metacall_value_id,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by type array @ids and variable arguments @va_args\n\n  @param[in] name\n    Name of the function\n\n  @param[in] ids\n    Array of types refered to @va_args\n\n  @param[in] size\n    Number of elements of the call\n\n  @param[in] va_args\n    Varidic function parameters\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallt_s(
        name: *const ::std::os::raw::c_char,
        ids: *const metacall_value_id,
        size: usize,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by type array @ids and variable arguments @va_args\n\n  @param[in] handle\n    Pointer to the handle returned by metacall_load_from_{file, memory, package}\n\n  @param[in] name\n    Name of the function\n\n  @param[in] ids\n    Array of types refered to @va_args\n\n  @param[in] size\n    Number of elements of the call\n\n  @param[in] va_args\n    Varidic function parameters\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallht_s(
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        ids: *const metacall_value_id,
        size: usize,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the function by @name\n\n  @param[in] name\n    Name of the function\n\n  @return\n    Function reference, null if the function does not exist"]
    pub fn metacall_function(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create an empty handler into a loader with name @name\n\n  @param[in] loader\n    Pointer to the loader which the handle belongs to\n\n  @param[in] name\n    Name of the handle\n\n  @param[out] handle_ptr\n    On success, returns the pointer to the handle created, otherwise NULL\n\n  @return\n    Return zero on success, different from zero on error"]
    pub fn metacall_handle_initialize(
        loader: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        handle_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Populate the objects of @handle_src into @handle_dest\n\n  @param[inout] handle_dest\n    Handle where the objects from @handle_src will be stored\n\n  @param[in] handle_src\n    Handle from where the objects will be copied\n\n  @return\n    Return zero on success, different from zero on error"]
    pub fn metacall_handle_populate(
        handle_dest: *mut ::std::os::raw::c_void,
        handle_src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the function by @name from @handle\n\n  @param[in] handle\n    Pointer to the handle returned by metacall_load_from_{file, memory, package}\n\n  @param[in] name\n    Name of the function\n\n  @return\n    Function reference, null if the function does not exist"]
    pub fn metacall_handle_function(
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the function parameter type id\n\n  @param[in] func\n    The pointer to the function obtained from metacall_function\n\n  @param[in] parameter\n    The index of the parameter to be retrieved\n\n  @param[out] id\n    The parameter type id that will be returned\n\n  @return\n    Return 0 if the @parameter index exists and @func is valid, 1 otherwhise"]
    pub fn metacall_function_parameter_type(
        func: *mut ::std::os::raw::c_void,
        parameter: usize,
        id: *mut metacall_value_id,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the function return type id\n\n  @param[in] func\n    The pointer to the function obtained from metacall_function\n\n\n  @param[out] id\n    The value id of the return type of the function @func\n\n  @return\n    Return 0 if the @func is valid, 1 otherwhise"]
    pub fn metacall_function_return_type(
        func: *mut ::std::os::raw::c_void,
        id: *mut metacall_value_id,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get minimun mumber of arguments accepted by function @func\n\n  @param[in] func\n    Function reference\n\n  @return\n    Return mumber of arguments"]
    pub fn metacall_function_size(func: *mut ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Check if the function @func is asynchronous or synchronous\n\n  @param[in] func\n    Function reference\n\n  @return\n    Return 0 if it is syncrhonous, 1 if it is asynchronous and -1 if the function is NULL"]
    pub fn metacall_function_async(func: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the handle by @name\n\n  @param[in] tag\n    Extension of the script\n\n  @param[in] name\n    Name of the handle\n\n  @return\n    Handle reference, null if the function does not exist"]
    pub fn metacall_handle(
        tag: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get name of a @handle\n\n  @param[in] handle\n    Pointer to the handle to be retrieved\n\n  @return\n    String that references the handle"]
    pub fn metacall_handle_id(handle: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Return a value representing the handle as a map of functions (or values)\n\n  @param[in] handle\n    Reference to the handle to be described\n\n  @return\n    A value of type map on success, null otherwise"]
    pub fn metacall_handle_export(
        handle: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by value array @args and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] args\n    Array of pointers to data\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallfv(
        func: *mut ::std::os::raw::c_void,
        args: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by value array @args and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] args\n    Array of pointers to data\n\n  @param[in] size\n    Number of function arguments\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallfv_s(
        func: *mut ::std::os::raw::c_void,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by variable arguments @va_args and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallf(func: *mut ::std::os::raw::c_void, ...) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by function @func and serial @buffer of size @size\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] buffer\n    String representing an array to be deserialized into arguments of the function\n\n  @param[in] size\n    Size of string @buffer\n\n  @param[in] allocator\n    Pointer to allocator will allocate the value\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallfs(
        func: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_char,
        size: usize,
        allocator: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by value map (@keys -> @values) and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] keys\n    Array of values representing argument keys\n\n  @param[in] values\n    Array of values representing argument values data\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallfmv(
        func: *mut ::std::os::raw::c_void,
        keys: *mut *mut ::std::os::raw::c_void,
        values: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a function anonymously by function @func and serial @buffer of size @size\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] buffer\n    String representing a map to be deserialized into arguments of the function\n\n  @param[in] size\n    Size of string @buffer\n\n  @param[in] allocator\n    Pointer to allocator will allocate the value\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallfms(
        func: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_char,
        size: usize,
        allocator: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Register a function by name @name and arguments @va_args\n\n  @param[in] name\n    Name of the function (if it is NULL, function is not registered into host scope)\n\n  @param[in] invoke\n    Pointer to function invoke interface (argc, argv, data)\n\n  @param[out] func\n    Will set the pointer to the function if the parameter is not null\n\n  @param[in] return_type\n    Type of return value\n\n  @param[in] size\n    Number of function arguments\n\n  @param[in] va_args\n    Varidic function parameter types\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacall_register(
        name: *const ::std::os::raw::c_char,
        invoke: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *mut *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        func: *mut *mut ::std::os::raw::c_void,
        return_type: metacall_value_id,
        size: usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Register a function by name @name and arguments @types\n\n  @param[in] name\n    Name of the function (if it is NULL, function is not registered into host scope)\n\n  @param[in] invoke\n    Pointer to function invoke interface (argc, argv, data)\n\n  @param[out] func\n    Will set the pointer to the function if the parameter is not null\n\n  @param[in] return_type\n    Type of return value\n\n  @param[in] size\n    Number of function arguments\n\n  @param[in] types\n    List of parameter types\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacall_registerv(
        name: *const ::std::os::raw::c_char,
        invoke: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *mut *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        func: *mut *mut ::std::os::raw::c_void,
        return_type: metacall_value_id,
        size: usize,
        types: *mut metacall_value_id,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Obtain the loader instance by @tag\n\n  @param[in] tag\n    Tag in which the loader is identified, normally it is the extension of the script\n\n  @return\n    Pointer the loader by @tag"]
    pub fn metacall_loader(tag: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Register a function by name @name and arguments @types\n\n  @param[in] loader\n    Opaque pointer to the loader in which you want to register the function (this allows to register the function into a different loader than the host)\n\n  @param[in] handle\n    Opaque pointer to the handle in which you want to register the function (if it is NULL, it will be defined on the global scope of the loader)\n\n  @param[in] name\n    Name of the function (if it is NULL, function is not registered into host scope)\n\n  @param[in] invoke\n    Pointer to function invoke interface (argc, argv, data)\n\n  @param[in] return_type\n    Type of return value\n\n  @param[in] size\n    Number of function arguments\n\n  @param[in] types\n    List of parameter types\n\n  @return\n    Zero if the function was registered properly, distinct from zero otherwise"]
    pub fn metacall_register_loaderv(
        loader: *mut ::std::os::raw::c_void,
        handle: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        invoke: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *mut *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        return_type: metacall_value_id,
        size: usize,
        types: *mut metacall_value_id,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Executes an asynchronous call to the function and registers a callback to be executed when a future is resolved (it does block)\n\n  @param[in] name\n    The name of the function to be called asynchronously\n\n  @param[in] args\n    Array of pointers to the values to be passed to the function\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacall_await(
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Awaits for a promise and registers a callback to be executed when a future is resolved\n\n  @param[in] f\n    The pointer to the future\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacall_await_future(
        f: *mut ::std::os::raw::c_void,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Executes an asynchronous call to the function and registers a callback to be executed when a future is resolved (it does block)\n\n  @param[in] name\n    The name of the function to be called asynchronously\n\n  @param[in] args\n    Array of pointers to the values to be passed to the function\n\n  @param[in] size\n    Number of elements of the array @args\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacall_await_s(
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an asynchronous function anonymously by value array @args and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] args\n    Array of pointers to values\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacallfv_await(
        func: *mut ::std::os::raw::c_void,
        args: *mut *mut ::std::os::raw::c_void,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an asynchronous function anonymously by value array @args and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] args\n    Array of pointers to values\n\n  @param[in] size\n    Number of elements of the array @args\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacallfv_await_s(
        func: *mut ::std::os::raw::c_void,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an asynchronous function anonymously by value array @args and function @func (offered without function pointers for languages without support to function pointers)\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] args\n    Array of pointers to values\n\n  @param[in] size\n    Number of elements of the array @args\n\n  @param[in] cb\n    Pointer to struct containing the function pointers to reject and resolve that will be executed when task completion or error\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacallfv_await_struct_s(
        func: *mut ::std::os::raw::c_void,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
        cb: metacall_await_callbacks,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an asynchronous function anonymously by value map (@keys -> @values) and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] keys\n    Array of values representing argument keys\n\n  @param[in] values\n    Array of values representing argument values data\n\n  @param[in] size\n    Number of elements of the arrays @keys and @values\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacallfmv_await(
        func: *mut ::std::os::raw::c_void,
        keys: *mut *mut ::std::os::raw::c_void,
        values: *mut *mut ::std::os::raw::c_void,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an asynchronous function anonymously by value map (@keys -> @values) and function @func\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] keys\n    Array of values representing argument keys\n\n  @param[in] values\n    Array of values representing argument values data\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacallfmv_await_s(
        func: *mut ::std::os::raw::c_void,
        keys: *mut *mut ::std::os::raw::c_void,
        values: *mut *mut ::std::os::raw::c_void,
        size: usize,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an asynchronous function anonymously by function @func and serial @buffer of size @size\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] buffer\n    String representing an array to be deserialized into arguments of the function\n\n  @param[in] size\n    Size of string @buffer\n\n  @param[in] allocator\n    Pointer to allocator will allocate the value\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacallfs_await(
        func: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_char,
        size: usize,
        allocator: *mut ::std::os::raw::c_void,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an asynchronous function anonymously by function @func and serial @buffer of size @size\n\n  @param[in] func\n    Reference to function to be called\n\n  @param[in] buffer\n    String representing a map to be deserialized into arguments of the function\n\n  @param[in] size\n    Size of string @buffer\n\n  @param[in] allocator\n    Pointer to allocator will allocate the value\n\n  @param[in] resolve_callback\n    Pointer to function that will be executed when task completion\n      @param[in] void *\n        Value representing the result of the future resolution\n      @param[in] void *\n        A reference to @data that will be used as a closure for the chain\n      @return\n        Value containing the result of the operation,\n        it will be wrapped into a future later on to be returned by the function\n\n  @param[in] reject_callback\n    Pointer to function that will be executed when task error (signature is identical as resolve_callback)\n\n  @param[in] data\n    Pointer to a context that will act as a closure for the chain\n\n  @return\n    Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future"]
    pub fn metacallfms_await(
        func: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_char,
        size: usize,
        allocator: *mut ::std::os::raw::c_void,
        resolve_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        reject_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the class by @name\n\n  @param[in] name\n    Name of the class\n\n  @return\n    Class reference, null if the class does not exist"]
    pub fn metacall_class(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a class method anonymously by value array @args (this procedure assumes there's no overloaded methods and does type conversion on values)\n\n  @param[in] cls\n    Pointer to the class\n\n  @param[in] name\n    Name of the method\n\n  @param[in] args\n    Array of pointers to data\n\n  @param[in] size\n    Number of elements of args array\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallv_class(
        cls: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a class method anonymously by value array @args and return value type @ret (helps to resolve overloading methods)\n\n  @param[in] cls\n    Pointer to the class\n\n  @param[in] name\n    Name of the method\n\n  @param[in] ret\n    Type of the return value of the method\n\n  @param[in] args\n    Array of pointers to data\n\n  @param[in] size\n    Number of elements of args array\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallt_class(
        cls: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        ret: metacall_value_id,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Create a new object instance from @cls by value array @args\n\n  @param[in] cls\n    Pointer to the class\n\n  @param[in] name\n    Name of the new object\n\n  @param[in] args\n    Array of pointers constructor parameters\n\n  @param[in] size\n    Number of elements of constructor parameters\n\n  @return\n    Pointer to the new object value instance"]
    pub fn metacall_class_new(
        cls: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get an attribute from @cls by @key name\n\n  @param[in] cls\n    Pointer to the class\n\n  @param[in] key\n    Name of the attribute to get\n\n  @return\n    Pointer to the class attribute value or NULL if an error occurred"]
    pub fn metacall_class_static_get(
        cls: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Set an attribute to @cls by @key name\n\n  @param[in] cls\n    Pointer to the class\n\n  @param[in] key\n    Name of the attribute to set\n\n  @param[in] value\n    Value to set\n\n  @return\n    Non-zero integer if an error ocurred"]
    pub fn metacall_class_static_set(
        cls: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call an object method anonymously by value array @args\n\n  @param[in] obj\n    Pointer to the object\n\n  @param[in] name\n    Name of the method\n\n  @param[in] args\n    Array of pointers to data\n\n  @param[in] size\n    Number of elements of args array\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallv_object(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Call a object method anonymously by value array @args and return value type @ret (helps to resolve overloading methods)\n\n  @param[in] obj\n    Pointer to the object\n\n  @param[in] name\n    Name of the method\n\n  @param[in] ret\n    Type of the return value of the method\n\n  @param[in] args\n    Array of pointers to data\n\n  @param[in] size\n    Number of elements of args array\n\n  @return\n    Pointer to value containing the result of the call"]
    pub fn metacallt_object(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        ret: metacall_value_id,
        args: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get an attribute from @obj by @key name\n\n  @param[in] obj\n    Pointer to the object\n\n  @param[in] key\n    Name of the attribute to get\n\n  @return\n    Pointer to the object attribute value or NULL if an error occurred"]
    pub fn metacall_object_get(
        obj: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Set an attribute to @obj by @key name\n\n  @param[in] obj\n    Pointer to the object\n\n  @param[in] key\n    Name of the attribute to set\n\n  @param[in] value\n    Value to set\n\n  @return\n    Non-zero integer if an error ocurred"]
    pub fn metacall_object_set(
        obj: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the value contained by throwable object @th\n\n  @param[in] th\n    Pointer to the throwable object\n\n  @return\n    Pointer to the value inside of the throwable or NULL in case of error"]
    pub fn metacall_throwable_value(th: *mut ::std::os::raw::c_void)
        -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide information about all loaded objects\n\n  @param[out] size\n    Size in bytes of return buffer\n\n  @param[in] allocator\n    Pointer to allocator will allocate the string\n\n  @return\n    String containing introspection information"]
    pub fn metacall_inspect(
        size: *mut usize,
        allocator: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide information about all loaded objects as a value\n\n  @return\n    Value containing introspection information"]
    pub fn metacall_inspect_value() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert the value @v to serialized string\n\n  @param[in] name\n    Name of the serial to be used\n\n  @param[in] v\n    Reference to the value\n\n  @param[out] size\n    Size of new allocated string\n\n  @param[in] allocator\n    Pointer to allocator will allocate the string\n\n  @return\n    New allocated string containing stringified value"]
    pub fn metacall_serialize(
        name: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_void,
        size: *mut usize,
        allocator: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Convert the string @buffer to value\n\n  @param[in] name\n    Name of the serial to be used\n\n  @param[in] buffer\n    String to be deserialized\n\n  @param[in] size\n    Size of string @buffer\n\n  @param[in] allocator\n    Pointer to allocator will allocate the value\n\n  @return\n    New allocated value representing the string (must be freed)"]
    pub fn metacall_deserialize(
        name: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_char,
        size: usize,
        allocator: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Clear handle from memory and unload related resources\n\n  @param[in] handle\n    Reference to the handle to be unloaded\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_clear(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the plugin extension handle to be used for loading plugins\n\n  @return\n    Pointer to the extension handle, or null if it failed to load"]
    pub fn metacall_plugin_extension() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the handle containing all the functionality of the plugins from core\n\n  @return\n    Pointer to the core plugin handle, or null if it failed to load"]
    pub fn metacall_plugin_core() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Get the plugin extension path to be used for accessing the plugins folder\n\n  @return\n    String containing the core plugin path, or null if it failed to load the plugin extension"]
    pub fn metacall_plugin_path() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Destroy MetaCall library\n\n  @return\n    Zero if success, different from zero otherwise"]
    pub fn metacall_destroy() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide the module version struct\n\n  @return\n    Static struct containing unpacked version"]
    pub fn metacall_version() -> *const metacall_version_type;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide the module version hexadecimal value\n    with format 0xMMIIPPPP where M is @major,\n    I is @minor and P is @patch\n\n  @param[in] major\n    Unsigned integer representing major version\n\n  @param[in] minor\n    Unsigned integer representing minor version\n\n  @param[in] patch\n    Unsigned integer representing patch version\n\n  @return\n    Hexadecimal integer containing packed version"]
    pub fn metacall_version_hex_make(
        major: ::std::os::raw::c_uint,
        minor: ::std::os::raw::c_uint,
        patch: ::std::os::raw::c_uint,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide the module version hexadecimal value\n    with format 0xMMIIPPPP where M is major,\n    I is minor and P is patch\n\n  @return\n    Hexadecimal integer containing packed version"]
    pub fn metacall_version_hex() -> u32;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide the module version string\n\n  @return\n    Static string containing module version"]
    pub fn metacall_version_str() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide the module version revision string\n\n  @return\n    Static string containing module version revision"]
    pub fn metacall_version_revision() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide the module version name\n\n  @return\n    Static string containing module version name"]
    pub fn metacall_version_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "  @brief\n    Provide the module information\n\n  @return\n    Static string containing module information"]
    pub fn metacall_print_info() -> *const ::std::os::raw::c_char;
}
